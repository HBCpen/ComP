# Next Greater Element

## 問題概要

配列 `A` が与えられます。配列の各要素 `A[i]` に対して、`j > i` であり `A[j] > A[i]` を満たすような最小のインデックス `j` に対応する要素 `A[j]` を見つけてください。もしそのような要素が存在しない場合は、特定の値（例: -1）を出力します。

全ての要素に対する Next Greater Element を含む配列を効率的に作成するアルゴリズムを作成してください。

### 例

`A = [2, 1, 5, 6, 2, 3]` の場合、結果は `[5, 5, 6, -1, 3, -1]` となります。

- `A[0]=2`: 右側で最初に `2` より大きいのは `5`
- `A[1]=1`: 右側で最初に `1` より大きいのは `5`
- `A[2]=5`: 右側で最初に `5` より大きいのは `6`
- `A[3]=6`: 右側に `6` より大きい要素はないので `-1`
- `A[4]=2`: 右側で最初に `2` より大きいのは `3`
- `A[5]=3`: 右側に `3` より大きい要素はないので `-1`

## 制約

- `1 <= A.length <= 10^5`
- `0 <= A[i] <= 10^9`

## 解法

### ブルートフォース - O(n^2)

最も単純な方法は、各要素 `A[i]` について、その右側 `A[i+1:]` を線形探索し、最初に見つかった `A[i]` より大きい値を記録することです。

このアプローチは、各要素に対して配列の残りの部分をスキャンするため、計算量が O(n^2) となり、制約によっては時間切れになる可能性があります。

### スタックを用いた解法 - O(n)

この問題はスタックデータ構造を用いることで、O(n) の計算量で効率的に解くことができます。

アルゴリズムは以下の通りです。

1.  結果を格納するための配列 `result` を、入力配列 `A` と同じサイズで作成し、すべての値を `-1` で初期化します。
2.  インデックスを格納するための空のスタック `stack` を用意します。
3.  配列 `A` の要素を左から右へ、インデックス `i` と値 `A[i]` を見ていきます。
4.  スタックが空ではなく、かつスタックの先頭にあるインデックス `peek_idx` に対応する値 `A[peek_idx]` が現在の値 `A[i]` よりも小さい間、以下の処理を繰り返します。
    a. これは、`A[peek_idx]` にとっての Next Greater Element が `A[i]` であることを意味します。
    b. スタックから `peek_idx` をポップします。
    c. `result[peek_idx]` に `A[i]` を設定します。
5.  現在のインデックス `i` をスタックにプッシュします。
6.  配列のすべての要素を見終わったら、`result` を返します。スタックに残っているインデックスは、右側に自分より大きい要素がなかったものに対応します（これらは初期値の `-1` のままです）。

**例:** `A = [2, 1, 5, 6, 2, 3]`

1.  `i=0, A[0]=2`: `stack = [0]`
2.  `i=1, A[1]=1`: `A[0] > A[1]` なのでスタックはそのまま。`stack = [0, 1]`
3.  `i=2, A[2]=5`:
    - `A[1] < 5` なので、`result[1]=5` に設定し、`1` をポップ。`stack = [0]`
    - `A[0] < 5` なので、`result[0]=5` に設定し、`0` をポップ。`stack = []`
    - `2` をプッシュ。`stack = [2]`
4.  `i=3, A[3]=6`:
    - `A[2] < 6` なので、`result[2]=6` に設定し、`2` をポップ。`stack = []`
    - `3` をプッシュ。`stack = [3]`
5.  `i=4, A[4]=2`: `A[3] > A[4]` なのでスタックはそのまま。`stack = [3, 4]`
6.  `i=5, A[5]=3`:
    - `A[4] < 3` なので、`result[4]=3` に設定し、`4` をポップ。`stack = [3]`
    - `A[3] > A[5]` なのでスタックはそのまま。
    - `5` をプッシュ。`stack = [3, 5]`

ループ終了。`result` は `[5, 5, 6, -1, 3, -1]` となります。`stack` に残った `3, 5` は `-1` のままです。
